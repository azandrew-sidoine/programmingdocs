# Modern C++ (Language Runtime Enhancements)

## Lambda Expression

The syntax of anonymous function might looks like:

```txt
[capture list] ([...parameters]) mutable(optional) exception attribute -> return type {
    // function body
}
```

> [capture list] -> List of attributes that the lambda function can access from the outer scope

- value capture type [value1, value2, ...]

It's a captured value passed as copy, not as reference to the lambda function.

```cpp
int main()
{
    int value = 0;
    auto mylambda = [&value] {
        // Interact with the reference variable
        return value;
    }
    std::cout<< "Stored value" << mylambda() << std::endl();
}
```

**Note**
The copy of the capture is passed to the lambda when it's created, not when it's called.

- Reference capture type [&value1, ....]

The outer attribute is passed by reference to the lambda expression making it possible to change it value when the lamdbda executes.

```cpp
int main()
{
    int ref = 0;
    auto mylambda = [&ref] {
        // Interact with the reference variable
        return ref;
    }
    std::cout<< "Stored reference" << mylambda() << std::endl();
}
```

- List of capture list implementation

> [] -> empty capture list
> [name1,name2,...] -> Capture a series of variables
> [&] -> Let the compiler deduce the referenced variables by itself
> [=] -> Let the compiler deduce values by itself

- Expression capture (`rvalue` capture) (C++14)

In this type of capture, the type of the capture is determined by the result of the rvalue expression:

```cpp
#include <iostream>
#include <memory> // Make use of std::unique<T>()
#include <utility> // Make use of std::move<T>()

int main()
{
    auto important = std::unique<int>(1);

    auto mylambda = [v1 = 1, v2 = std::move<int>(important)](int x, int y) -> int {
        return x + y + v1 + (*v2)
    }

    std::cout << mylambda(3, 4) << std::endl;
}
```

**Note** `rvalue` capture are mostly used for explicit pointer that cannot be caugth using value or reference capture like the result of `std::unique<T>()` call.

## Generic Lambda (C++14)

C++ lambda expressions are not regular functions, without further specification on the typed parameter list, lambda expressions cannot utilize templates. From C++14, `formal parameters of the lambda` function can use the `auto` keyword to utilize template generics:

```cpp
#include <type_traits>

int main()
{
    auto generic = [] (auto int, auto y) -> decltype<x + y> {
        return x + y;
    }
}
```

## Function object wrapper (std::function<T>) (functional namespace)

Although the features are part of the standard library and not found in `runtime`, it enhances the runtime capabilities of the `C++` language.

**Note**
The essence of a `Lambda expression` is an object of a class type `(called a closure type)` that is similar to a `function object type (called a closure object)`. When the capture list of a `Lambda expression is empty`, the closure object can also be converted to a `function pointer value` for delivery:

```cpp
#include <iostream>

using FunctionType = void(int); // Function pointer

void functional(FunctionType f)
{
    return f(1);
}

int main()
{
    auto f = [](int x) {
        std::cout << "X: " << x << std::endl;
    }

    functional(f); // Call function by pointer
    f(1); // Call lambda expression

    return 0;
}
```

From C++11, type of objects that can be collectively called are called `callable type`, and is introduced by `std::function` from the STL (which is a generic polymorphic function wrapper whose instances can be stored, copy and call any target entity).

```cpp
#include <functional>
// ... other includes

int f(int x)
{
    return x;
}

int main()
{
    int x = 10;
    std::function<int(int)> func = f;
    std::function<int(int)> func_l = [&](int value) -> int {
        return 1 + x + value;
    }
    // Invoking functions
    std::cout << func(10) << std::endl;
    std::cout << func_l(10) << std::endl;
}
```

- std::bind and std::placeholder

They allow to pass partial parameters to a function in advance and later pass the rest if required:

```cpp
int f(int x, int y, int y)
{
    // ...
}

int main()
{
    // Bind parameter 1 , 2 to function f
    // and use std::placeholder::_1 as placeholder for the 1st parameter
    auto fn = std::bind(f, std::placeholder::_1, 1, 2);

    // 1 serve as the first parameter to the function when called
    fn(1);
}
```

## Value references (rvalue, lvalue, etc...) (C++11)

> Lvalue -> It's a persistence object that still exist after expression
> RValue -> Temporary object that no longer exist after the expression is evaluated.
    > Pvalue -> Pure `rvalue` are temporary value generated by the expression of non-references, Lambda, origial literals, etc...
**Note**
String literal is an lvalue with type `const char[]`
    > Xvalue -> expiring value is the concept proposed by C++11 to introduce rvalue references (so in traditional C++, pure rvalue and rvalue are the same concepts), a value that is destroyed but can be moved.

> T && -> creates an xvalue variable (it extends the lifecycle of the rvalue/temparary value as long as the variable is alive.) that can be moved.

- std::move() (C++11)

C++11 introduced std::move that allow developpers to explicitly move/convert lvalue reference to rvalue reference.
It optimize runtime code execution by removing copy overhead of lvalues.

```cpp
#include <utility>

int main()
{
    std::string lstring = "string .";
    // std::string&& rstring1 = lstring; // Illegal error -> std::string&& rstring1 = std::static_cast<std::string&&>(lstring);
    std::string&& rstring = std::move(lstring); // std::move convert lvalue to rvalue

    const std::string& lv2 = lstring + lstring; // legal, const lvalue reference can // extend temp variable's lifecycle
    // lv2 += "Test."; // Illegal const ref can't be modified

    std::string&& rv2 = lstring + lv2; // rvalue reference extends lifecycle -> xvalue

    rv2 += "string"; // Legal non const ref can be modified
}
```

**Note**
`Non-const references` (T&) does not bind to rvalue. Only `const references` (const T&) bind to rvalues, because fortran needs it.

## Move semantics

```cpp
class A {

    private:
        int *pointer;

    public:
        A(): pointer(new int{1}) {
            std::cout << "Default constructor" << pointer << std::endl;
        }

        // Copy constuctor
        A(const A& a): pointer(new int{*a.pointer}) {
            std::cout << "Copy constructor" << pointer << std::endl;
        }
        
        // Move constructor constuctor
        A(A&& a): pointer(new int{a.pointer}) {
            // When writing a move constructor, remember to always 
            // set the reference of the object being move to a nullptr for garbage
            // collection
            a.pointer = nullptr
            std::cout << "Move constructor" << pointer << std::endl;
        }

        ~A() {
            std::cout << "Destructor" << std::endl;
            delete pointer;
        }
};
```

- Type forwarding (`std::forward<T>()`)

In utility types, only `std::forward` does not cause any extra copies and perfectly forwards (passes) the arguments of the function to other functions that are called internally.

**Note**
`std::forward` is the same as `std::move`, and nothing is done. `std::move` simply converts the `lvalue to the rvalue`. `std::forward` is just a simple conversion of the parameters. From the point of view of the phenomenon, `std::forward<T>(v) is the same as static_cast<T&&>(v)`.
